package com.chris.some.code.study.geektime.datastructureandalgorithm.datastructure.linked;

/**
 * 链表
 * <p>
 * 经典链表应用场景：LRU缓存淘汰算法
 * <p>
 * 缓存常见应用场景：CPU缓存，数据库缓存，浏览器缓存
 * <p>
 * 常见缓存淘汰策略：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）
 * <p>
 * 链表不需要连续空间，通过指针将一组零散内存串联起来
 * <p>
 * 常见链表结构：单链表、双向链表、循环链表
 * <p>
 * 单链表
 * <pre>
 *     时间复杂度
 *     <pre>
 *         1、插入/删除：只需要考虑相邻节点的指针改变，O(1)
 *         2、随机访问：O(n)
 *     </pre>
 * </pre>
 * 循环链表：尾节点指针指向头节点，处理具有环型结构特点的数据，例如：约瑟夫问题
 * <p>
 * 双向链表：双指针，后继指针指向后面的节点，前继指针指向前面的节点，支持O(1)时间找到前一个节点
 * <p>
 * 基于链表实现LRU缓存淘汰算法
 * <pre>
 *     维护一个有序单链表，新数据被访问时，从链表头开始遍历链表
 *     1、如果数据已被缓存在链表中，遍历得到数据对应节点，将数据从原来位置删除，插入到链表头
 *     2、如果数据没有缓存在链表中
 *     <pre>
 *         1、如果缓存未满，将数据插入到链表头
 *         2、如果缓存已满，将链表尾节点删除，将数据插入链表头
 *     </pre>
 *     优化思路：引入散列表记录数据位置，将访问时间复杂度降到O(1)
 * </pre>
 * <p>
 * 判断字符串是否回文
 * <pre>
 *     使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等
 *     时间复杂度：O(n)
 *     空间复杂度：O(1)
 * </pre>
 * 写链表代码技巧
 * <pre>
 *     1、理解指针或引用的含义。将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量
 *     2、警惕指针丢失和内存泄漏。将x插入a和b之间，a->next = x; x->next = a->next：这样b就丢失了，x->next = a->next; a->next = x;
 *     3、利用哨兵简化实现难度。
 *     4、重点留意边界条件处理。
 * </pre>
 * 链表练习题目
 * <pre>
 *     1、单链表反转
 *     2、链表中环的检测
 *     3、两个有序的链表合并
 *     4、删除链表倒数第n个结点
 *     5、求链表的中间结点
 * </pre>
 */
public class LinkedStudy {
}
